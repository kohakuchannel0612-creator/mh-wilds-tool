<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MHWilds 乱舞ツール（仮）</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 16px; line-height: 1.4; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; max-width: 1000px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 360px 1fr; } }

    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; background: #fff; }
    .row { display: grid; grid-template-columns: 1fr 120px; gap: 8px; align-items: center; margin: 8px 0; }
    label { font-size: 13px; color: #333; }
    input, select { width: 100%; padding: 6px 8px; border: 1px solid #ccc; border-radius: 8px; }
    input[type="checkbox"] { width: auto; }
    .btns { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button.primary { background: #222; color: #fff; border-color: #222; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 6px; text-align: left; }
    th { background: #fafafa; position: sticky; top: 0; z-index: 1; }
    .muted { color: #666; font-size: 12px; }
    .ok { color: #0a7; }
    .ng { color: #c22; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    /* 既存の style の下に追記でOK */

  .sheet {
    display: grid;
    gap: 12px;
  }

  /* 上：各種設定（8〜10個を横に流す） */
  .settingsGrid {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr)); /* 4列 */
    gap: 10px 14px;
    align-items: end;
  }
  @media (min-width: 1100px) {
    .settingsGrid { grid-template-columns: repeat(6, minmax(0, 1fr)); } /* 横に広いなら6列 */
  }

  .field {
    display: grid;
    gap: 4px;
  }
  .field label {
    font-size: 12px;
    color: #444;
  }
  .field input, .field select {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid #ccc;
    border-radius: 999px; /* シートの丸いプルダウン感 */
    background: #fff;
  }

  .sectionTitle {
    font-weight: 700;
    font-size: 13px;
    margin: 4px 0 0;
  }

  /* 下：スキル群（スクショみたいに横へ並べる） */
  .skillGrid {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr)); /* 4列 */
    gap: 10px 14px;
  }
  @media (min-width: 1100px) {
    .skillGrid { grid-template-columns: repeat(6, minmax(0, 1fr)); } /* 横広なら6列 */
  }

  .divider {
    border: none;
    border-top: 1px solid #eee;
    margin: 8px 0;
  }

  /* ON/OFFは見た目をselectに寄せる */
  .toggleRow {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    align-items: center;
  }
  .toggleRow input[type="checkbox"] {
    transform: scale(1.2);
  }
    /* 上下2段のレイアウト */
  .stack {
    display: grid;
    gap: 16px;
    max-width: 1100px;
  }

  .panel {
    border: 1px solid #ddd;
    border-radius: 24px;          /* 角丸大きめ */
    padding: 16px;
    background: #fff;
    min-height: 240px;            /* 枠の高さを確保（好みで調整） */
  }

  .panelTitle {
    font-size: 16px;
    font-weight: 700;
    margin: 0 0 10px;
  }

    .sheetGrid{
  display:grid;
  grid-template-columns: repeat(6, minmax(0, 1fr));
  gap:10px;
  align-items:start;
}

.sheetTitle{
  grid-column: 1 / -1;
  font-weight: 700;
  font-size: 13px;
  padding: 6px 8px;
  background: #f3f6ff;
  border: 1px solid #d7e0ff;
  border-radius: 10px;
}

.cell{
  border: 1px solid #e6e6e6;
  border-radius: 10px;
  padding: 8px;
  background:#fff;
  min-height: 74px;
}

.cell .lbl{
  font-size: 12px;
  color:#333;
  margin-bottom: 6px;
}

.cell .hint{
  margin-top: 6px;
  font-size: 11px;
  color:#777;
}

.runArea{
  grid-column: 5 / 7; /* 右側に大きめボタン */
  grid-row: span 2;
  border: 1px solid #cfe0ff;
  background: #eef5ff;
  border-radius: 12px;
  padding: 10px;
  min-height: 160px;
}

  /* 既存のbody等はそのままでOK */

  .wrap { max-width: 1100px; margin: 0 auto; }
  .sheet-title { font-size: 22px; font-weight: 700; margin: 10px 0 14px; }
  .hint {
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 10px 12px;
    background: #fff;
    color: #444;
    margin: 0 0 14px;
  }

  .card {
    border: 1px solid #d8d8d8;
    border-radius: 14px;
    background: #fff;
    overflow: hidden;
    box-shadow: 0 1px 0 rgba(0,0,0,0.03);
    margin-bottom: 14px;
  }

  .card-head {
    background: #eaf3fb;
    padding: 10px 12px;
    font-weight: 700;
    color: #1f2a37;
    border-bottom: 1px solid #d8d8d8;
  }

  .card-body { padding: 12px; }

  /* “シートっぽい” 横並びグリッド */
  .grid-6 { display: grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap: 10px; }
  .grid-4 { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 10px; }
  .grid-3 { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
  .grid-2 { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }

  @media (max-width: 980px){
    .grid-6 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .grid-4 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .grid-3 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .grid-2 { grid-template-columns: 1fr; }
  }

  .field { display: grid; grid-template-columns: 1fr; gap: 6px; }
  .field label { font-size: 12px; color: #374151; }
  .field .sub { font-size: 11px; color: #6b7280; }

  input, select {
    width: 100%;
    padding: 8px 10px;
    border: 1px solid #cfd3d8;
    border-radius: 10px;
    font-size: 14px;
    background: #fff;
  }

  .row-inline { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  @media (max-width: 980px){ .row-inline { grid-template-columns: 1fr; } }

  .btnbar { display: flex; gap: 10px; align-items: center; justify-content: flex-end; }
  .btnbar .left { margin-right: auto; color: #6b7280; font-size: 12px; }

  button.primary {
    padding: 12px 18px;
    border-radius: 12px;
    border: 1px solid #2563eb;
    background: #2563eb;
    color: #fff;
    font-weight: 700;
  }
  button.ghost {
    padding: 10px 14px;
    border-radius: 12px;
    border: 1px solid #cfd3d8;
    background: #f7f7f7;
  }


  </style>
</head>

<body>
  <h1>MHWilds 乱舞ツール（仮）</h1>
  <p class="muted">
    ※計算ロジックは <span class="mono">calc()</span> 以下に隔離。UIは入力→計算→表表示だけ。<br>
    ※完成後に公開/広告を入れる想定のフックは用意してあります（今は無効）。
  </p>

<div class="stack">

  <!-- ===== 上：入力 ===== -->
  <section class="panel">
    <div class="panelTitle">入力</div>

      <!-- 基本 -->
<!-- ===== Sheet-like Inputs ===== -->
<section class="card">
  <h2 style="font-size:14px;margin:0 0 8px;">入力（シート配置）</h2>

  <!-- %入力方式：0.45 or 45 を統一するための注意 -->
  <p class="muted" style="margin:0 0 10px;">
    ※%系は「0.45入力」でも「45入力」でもOK（内部で自動補正）
  </p>

  <div class="sheetGrid">

    <!-- ===== 各種設定（上段） ===== -->
    <div class="sheetTitle">各種設定</div>

    <div class="cell">
      <div class="lbl">基礎内部攻撃力</div>
      <input id="A_base" type="number" value="205" step="1">
    </div>

    <div class="cell">
      <div class="lbl">基礎属性値</div>
      <input id="E_base" type="number" value="270" step="1">
    </div>

    <div class="cell">
      <div class="lbl">斬れ味（物理倍率）</div>
      <input id="sharpRaw" type="number" value="1.32" step="0.001">
    </div>

    <div class="cell">
      <div class="lbl">斬れ味（属性倍率）</div>
      <input id="sharpElem" type="number" value="1.151" step="0.001">
    </div>

    <div class="cell">
      <div class="lbl">% 物理肉質</div>
      <input id="hzvRaw" type="number" value="45" step="0.1">
      <div class="hint">0.45 でも 45 でもOK</div>
    </div>

    <div class="cell">
      <div class="lbl">% 属性肉質</div>
      <input id="hzvElem" type="number" value="5" step="0.1">
      <div class="hint">0.05 でも 5 でもOK</div>
    </div>

    <div class="cell">
      <div class="lbl">% 基礎会心率</div>
      <input id="critBase" type="number" value="5" step="0.1">
      <div class="hint">0.05 でも 5 でもOK</div>
    </div>

    <div class="cell">
      <div class="lbl">復元ボーナス総枠</div>
      <input id="totalSlots" type="number" value="5" step="1" min="0">
    </div>

    <div class="cell">
      <div class="lbl">切れ味ボーナス枠</div>
      <input id="sharpCnt" type="number" value="1" step="1" min="0">
    </div>

    <div class="cell">
      <div class="lbl">表示件数（TopN）</div>
      <input id="topN" type="number" value="10" step="1" min="1" max="200">
    </div>

    <div class="cell">
      <div class="lbl">丸め方式</div>
      <input id="roundMode" type="number" value="9" step="1" min="0">
    </div>

    <!-- ===== 攻撃力関係 ===== -->
    <div class="sheetTitle">攻撃力関係</div>

    <div class="cell">
      <div class="lbl">攻撃</div>
      <select id="attackSkillLv">
        <option value="0">0</option><option value="1">1</option><option value="2">2</option>
        <option value="3">3</option><option value="4">4</option><option value="5" selected>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">巧撃</div>
      <select id="kougekiLv">
        <option>0</option><option>1</option><option>2</option><option selected>3</option><option>4</option><option>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">フルチャージ</div>
      <select id="fullChargeLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">攻めの守勢</div>
      <select id="semeNoShuseiLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">逆襲</div>
      <select id="gyakushuLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">ヌシの魂</div>
      <select id="nushiNoTamashiiOn">
        <option value="OFF" selected>OFF</option>
        <option value="ON">ON</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">心眼（肉質&lt;0.45で有効）</div>
      <select id="shinganLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">黒蝕一体Ⅱ</div>
      <select id="kokushokuIttaiOn">
        <option value="OFF" selected>OFF</option>
        <option value="ON">ON</option>
      </select>
    </div>

    <!-- ===== 属性関係 ===== -->
    <div class="sheetTitle">属性関係</div>

    <div class="cell">
      <div class="lbl">属性攻撃強化Lv</div>
      <select id="elemAtkUpLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">災禍転福</div>
      <select id="saikaLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">宣戦呼応</div>
      <select id="senseiKououLv">
        <option selected>0</option><option>1</option><option>2</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">会心撃【属性】</div>
      <select id="critAttackElemLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <!-- ===== 会心関係 ===== -->
    <div class="sheetTitle">会心関係</div>

    <div class="cell">
      <div class="lbl">超会心Lv</div>
      <select id="superCritLv">
        <option>0</option><option>1</option><option>2</option><option>3</option>
        <option selected>4</option><option>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">弱点特攻</div>
      <select id="wexLv">
        <option>0</option><option>1</option><option>2</option><option>3</option><option>4</option><option selected>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">渾身</div>
      <select id="konshinLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">力の解放</div>
      <select id="chikaraNoKaihouLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">狂竜症克服</div>
      <select id="kyouryuuKokufukuOn">
        <option value="OFF" selected>OFF</option>
        <option value="ON">ON</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">無我の境地</div>
      <select id="mugaLv">
        <option selected>0</option><option>1</option><option>2</option><option>3</option>
      </select>
    </div>

    <!-- ===== 複数（挑戦者/連撃） ===== -->
    <div class="sheetTitle">複数</div>

    <div class="cell">
      <div class="lbl">挑戦者</div>
      <select id="challengerLv">
        <option>0</option><option>1</option><option>2</option><option>3</option><option>4</option><option selected>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">連撃</div>
      <select id="rengekiLv">
        <option>0</option><option>1</option><option>2</option><option>3</option><option>4</option><option selected>5</option>
      </select>
    </div>

    <div class="cell">
      <div class="lbl">連撃強化</div>
      <select id="rengekiBoostLv">
        <option>0</option><option>1</option><option selected>2</option>
      </select>
    </div>

    <!-- 実行ボタン（シートの「最適化実行」っぽい位置） -->
    <div class="runArea">
      <button class="primary" id="btnCalc" style="width:100%; height:100%; font-size:16px;">最適化実行</button>
    </div>

  </div>

  <div class="btns" style="margin-top:12px;">
    <button id="btnReset">リセット</button>
  </div>

  <p class="muted" id="status"></p>
</section>


      
      <!-- 将来の広告（今は隠す） -->
      <div id="ads-bottom" style="display:none; margin-top:12px; border-top:1px dashed #ddd; padding-top:10px;">
        <!-- 広告コードは完成後にここへ -->
      </div>
    </section>

   <!-- ===== 下：結果 ===== -->
  <section class="panel">
    <div class="panelTitle">結果</div>

    <div class="muted" id="summary"></div>

    <div style="overflow:auto; max-height:55vh; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>Rank</th>
            <th>期待ダメ</th>
            <th>激化タイプ</th>
            <th>復元ボーナス</th>
            <th>最終会心率</th>
            <th>属性(上限前)</th>
            <th>属性(適用後)</th>
            <th>上限</th>
            <th>上限?</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </section>

</div>

<script>
/** =========================
 *  公開/広告スイッチ（完成後に true）
 *  ========================= */
const IS_PUBLIC = false;

/** =========================
 *  ここから「計算ロジック」ゾーン
 *  UIとは切り離す
 *  ========================= */

const CRIT_MULT_BY_SUPERCRIT = { 0:1.25, 1:1.28, 2:1.31, 3:1.34, 4:1.37, 5:1.40 };

// 乱舞グループ（あなたの定義をそのまま）
const RAMBU_GROUPS = [
  { mv: 18, count: 2, elem: 1.0 },
  { mv: 6,  count: 2, elem: 0.6 },
  { mv: 10, count: 2, elem: 0.6 },
  { mv: 4,  count: 2, elem: 0.8 },
  { mv: 20, count: 2, elem: 0.8 },
  { mv: 11, count: 2, elem: 0.8 },
  { mv: 16, count: 2, elem: 0.6 },
  { mv: 6,  count: 1, elem: 0.8 },
  { mv: 25, count: 1, elem: 0.8 },
  { mv: 22, count: 1, elem: 0.6 },
  { mv: 8,  count: 1, elem: 0.6 },
  { mv: 5,  count: 1, elem: 0.6 },
  { mv: 22, count: 1, elem: 0.6 },
  { mv: 5,  count: 1, elem: 0.8 },
  { mv: 14, count: 1, elem: 0.8 },
  { mv: 18, count: 1, elem: 0.8 },
  { mv: 8,  count: 1, elem: 0.8 },
  { mv: 18, count: 1, elem: 0.8 },
  { mv: 36, count: 2, elem: 0.8 },
];

// --- Restoration bonus definitions (GASと同じ) ---
const BONUS_OPTIONS = [
  // Attack
  { id: "攻撃I",  cat: "atk", isEX: false, atk: 5,  elem: 0,  aff: 0.00 },
  { id: "攻撃II", cat: "atk", isEX: false, atk: 6,  elem: 0,  aff: 0.00 },
  { id: "攻撃III",cat: "atk", isEX: false, atk: 9,  elem: 0,  aff: 0.00 },
  { id: "攻撃EX", cat: "atk", isEX: true,  atk: 12, elem: 0,  aff: 0.00 },

  // Element
  { id: "属性I",  cat: "elm", isEX: false, atk: 0,  elem: 20, aff: 0.00 },
  { id: "属性II", cat: "elm", isEX: false, atk: 0,  elem: 30, aff: 0.00 },
  { id: "属性EX", cat: "elm", isEX: true,  atk: 0,  elem: 50, aff: 0.00 },

  // Affinity
  { id: "会心I",  cat: "aff", isEX: false, atk: 0,  elem: 0,  aff: 0.05 },
  { id: "会心II", cat: "aff", isEX: false, atk: 0,  elem: 0,  aff: 0.06 },
  { id: "会心III",cat: "aff", isEX: false, atk: 0,  elem: 0,  aff: 0.08 },
  { id: "会心EX", cat: "aff", isEX: true,  atk: 0,  elem: 0,  aff: 0.10 },
];

// --- 激化（3種）定義：ここだけ直せば全体に反映される ---
const GEKIKA_TRIALS = [
  { type: "攻撃激化", A_add: +10, crit_add: -0.15, elem_add:  0 },
  { type: "会心激化", A_add: -10, crit_add: +0.10, elem_add: -20 },
  { type: "属性激化", A_add:   0, crit_add: -0.05, elem_add: +30 },
];


function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
function round1(x){ return Math.round(x*10)/10; }

function isOn_(v){
  if (v === true) return true;
  if (v === false) return false;
  const s = String(v).trim().toUpperCase();
  return (s === "ON" || s === "TRUE" || s === "1" || s === "YES");
}

function getCritAttackElemMult(lv){
  switch (Number(lv) || 0) {
    case 1: return 1.05;
    case 2: return 1.10;
    case 3: return 1.15;
    default: return 1.0;
  }
}

function getKougekiBonus(lv){
  switch (Number(lv) || 0) {
    case 1: return 10;
    case 2: return 15;
    case 3: return 20;
    case 4: return 25;
    case 5: return 30;
    default: return 0;
  }
}

function getFullChargeBonus(lv){
  switch (Number(lv) || 0) {
    case 1: return 3;
    case 2: return 6;
    case 3: return 10;
    case 4: return 15;
    case 5: return 20;
    default: return 0;
  }
}

function getSemeNoShuseiBonus(lv){
  switch (Number(lv) || 0) {
    case 1: return 1.05;
    case 2: return 1.10;
    case 3: return 1.15;
    default: return 1.0;
  }
}

function getGyakushuBonus(lv){
  switch (Number(lv) || 0) {
    case 1: return 10;
    case 2: return 15;
    case 3: return 25;
    default: return 0;
  }
}

function getWeaknessExploitAffAdd_(lv, hzvRaw){
  if (!Number.isFinite(hzvRaw) || hzvRaw < 0.45) return 0.0;
  const L = clamp(Number(lv) || 0, 0, 5);
  switch (L) {
    case 1: return 0.05;
    case 2: return 0.10;
    case 3: return 0.15;
    case 4: return 0.20;
    case 5: return 0.30;
    default: return 0.0;
  }
}

function getKonshinAffAdd_(lv){
  const L = clamp(Number(lv) || 0, 0, 3);
  switch (L) {
    case 1: return 0.10;
    case 2: return 0.20;
    case 3: return 0.30;
    default: return 0.0;
  }
}

function getChikaraNoKaihouAffAdd_(lv){
  const L = clamp(Number(lv) || 0, 0, 5);
  switch (L) {
    case 1: return 0.10;
    case 2: return 0.20;
    case 3: return 0.30;
    case 4: return 0.40;
    case 5: return 0.50;
    default: return 0.0;
  }
}

function getChallengerBonus_(lv){
  const L = clamp(Number(lv) || 0, 0, 5);
  switch (L) {
    case 1: return { atkAdd: 4,  affAdd: 0.03 };
    case 2: return { atkAdd: 8,  affAdd: 0.05 };
    case 3: return { atkAdd: 12, affAdd: 0.07 };
    case 4: return { atkAdd: 16, affAdd: 0.10 };
    case 5: return { atkAdd: 20, affAdd: 0.15 };
    default: return { atkAdd: 0,  affAdd: 0.00 };
  }
}

function getRengekiBonus_(lv){
  const L = clamp(Number(lv) || 0, 0, 5);
  switch (L) {
    case 1: return { atkAdd: 8,  elemAdd: 40 };
    case 2: return { atkAdd: 10, elemAdd: 60 };
    case 3: return { atkAdd: 12, elemAdd: 80 };
    case 4: return { atkAdd: 15, elemAdd: 100 };
    case 5: return { atkAdd: 18, elemAdd: 120 };
    default: return { atkAdd: 0,  elemAdd: 0 };
  }
}

function getRengekiBoostAtkAdd_(lv){
  const L = clamp(Number(lv) || 0, 0, 2);
  switch (L) {
    case 1: return 8;
    case 2: return 18;
    default: return 0;
  }
}

function getSaikaElemMult_(lv){
  const L = clamp(Number(lv) || 0, 0, 3);
  switch (L) {
    case 1: return 1.05;
    case 2: return 1.10;
    case 3: return 1.15;
    default: return 1.0;
  }
}

function getMugaNoKyouchiAffAdd_(lv){
  const L = clamp(Number(lv) || 0, 0, 3);
  switch (L) {
    case 1: return 0.03;
    case 2: return 0.06;
    case 3: return 0.10;
    default: return 0.0;
  }
}


function getAttackSkillMult(lv){ return (lv===4)?1.02:(lv===5)?1.04:1.0; }
function getAttackSkillAdd(lv){ return (lv===1)?3:(lv===2)?5:(lv===3)?7:(lv===4)?8:(lv===5)?9:0; }

function getShinganAtkMult_(lv){
  lv = clamp(Number(lv)||0,0,3);
  return (lv===1)?1.10:(lv===2)?1.20:(lv===3)?1.30:1.00;
}

function getSenseiKououBonus_(lv){
  lv = clamp(Number(lv)||0,0,2);
  if(lv===1) return { elemMult:1.20, elemAdd:20 };
  if(lv===2) return { elemMult:1.30, elemAdd:40 };
  return { elemMult:1.00, elemAdd:0 };
}

// 属性攻撃強化（分割済み想定）
function getElemAtkUpMult_(lv){
  lv = clamp(Number(lv)||0,0,3);
  if(lv===2) return 1.1;
  if(lv===3) return 1.2;
  return 1.0; // Lv0,1は乗算なし
}
function getElemAtkUpAdd_(lv){
  lv = clamp(Number(lv)||0,0,3);
  if(lv===1) return 40;
  if(lv===2) return 50;
  if(lv===3) return 60;
  return 0;
}

function elementCapFromBase(baseElem){
  return Math.max(baseElem + 400, baseElem * 2.3);
}



function calcRambuExpectedDamage(params){
  const {
    A, E,
    sharpRaw, sharpElem,
    hzvRaw, hzvElem,
    critRate, critMult,
    elemBonus,
    critAttackElemLv,
    roundMode
  } = params;

  const r = clamp(critRate, 0, 1);
  const eBonus = (elemBonus == null) ? 1.0 : elemBonus;
  const mode = Number(roundMode) || 0;

  let total = 0;

  for (const g of RAMBU_GROUPS) {
    const rawBasePerHit = A * (g.mv / 100) * sharpRaw * hzvRaw;

    const elemBasePerHit = (E / 10) * g.elem * sharpElem * hzvElem * eBonus;

    const elemBonusMultiplier = getCritAttackElemMult(critAttackElemLv);
    const elemAdjusted = elemBasePerHit * ((1 - r) + r * elemBonusMultiplier);

    if (mode === 1) {
      total += (rawBasePerHit * ((1 - r) + r * critMult) + elemAdjusted) * g.count;

    } else if (mode === 2) {
      const perHit = rawBasePerHit * ((1 - r) + r * critMult) + elemAdjusted;
      total += Math.floor(perHit) * g.count;

    } else if (mode === 3) {
      const nonCrit = Math.floor(rawBasePerHit + elemAdjusted);
      const crit    = Math.floor(rawBasePerHit * critMult + elemAdjusted);
      const expHit  = (1 - r) * nonCrit + r * crit;
      total += expHit * g.count;

    } else if (mode === 4) {
      const elemInt = Math.floor(elemAdjusted);
      const rawNonCritInt = Math.floor(rawBasePerHit);
      const rawCritInt    = Math.floor(rawBasePerHit * critMult);
      const nonCrit = rawNonCritInt + elemInt;
      const crit    = rawCritInt + elemInt;
      const expHit = (1 - r) * nonCrit + r * crit;
      total += expHit * g.count;

    } else if (mode === 5) {
      const perHit = rawBasePerHit * ((1 - r) + r * critMult) + elemAdjusted;
      total += Math.floor(perHit * g.count);

    } else if (mode === 6) {
      total += (rawBasePerHit * ((1 - r) + r * critMult) + elemAdjusted) * g.count;

    } else if (mode === 7) {
      const rawPart  = rawBasePerHit * ((1 - r) + r * critMult) * g.count;
      const elemPart = Math.floor(elemAdjusted * g.count);
      total += rawPart + elemPart;

    } else if (mode === 9) {
      const rawNonCrit = round1(rawBasePerHit);
      const rawCrit    = round1(rawBasePerHit * critMult);
      const elem       = round1(elemAdjusted);
      const expHit = (1 - r) * (rawNonCrit + elem) + r * (rawCrit + elem);
      total += expHit * g.count;

    } else if (mode === 10) {
      const rawNonCrit = round1(rawBasePerHit);
      const rawCrit    = round1(rawBasePerHit * critMult);
      const elem       = round1(elemAdjusted);
      const expHit = (1 - r) * (rawNonCrit + elem) + r * (rawCrit + elem);
      total += expHit * g.count;

    } else {
      total += (rawBasePerHit * ((1 - r) + r * critMult) + elemAdjusted) * g.count;
    }
  }

  if (mode === 10) return round1(total);
  if (mode === 6) return Math.floor(total);
  return total;
}



function calcOptimizedTopN(input){

  const ctx = buildFixedCtx_(input); // ★追加：固定係数は一回だけ
  // スロット条件
  const totalSlots = Number(input.totalSlots);
  const sharpCnt   = Number(input.sharpCnt);
  const topN       = Math.max(1, Number(input.topN) || 10);

  if (!Number.isFinite(totalSlots) || totalSlots <= 0) throw new Error("復元ボーナス総枠(totalSlots)が不正です");
  if (!Number.isFinite(sharpCnt) || sharpCnt < 0 || sharpCnt > totalSlots) throw new Error("切れ味枠(sharpCnt)が不正です");

  const n = totalSlots - sharpCnt; // 最適化枠
  // n=0なら探索せず1件だけ返す
  if (n === 0) {
  // GASと同じ：n===0 は激化を評価しない（復元も激化もない前提）
  const A_final = (input.A_base * ctx.atkMultTotal) + ctx.atkFlatAfterMultTotal;

  const elemBase_mod = input.E_base;
  const elemUncapped0 = (elemBase_mod * ctx.elemMulted) + ctx.elemAdded;
  const elemCap0 = elementCapFromBase(elemBase_mod);
  const E_final0 = Math.min(elemUncapped0, elemCap0);

  const critFinal0 = clamp(input.critBase + ctx.critExtra, 0, 1);

  const dmg0 = calcRambuExpectedDamage({
    A: A_final,
    E: E_final0,
    sharpRaw: input.sharpRaw,
    sharpElem: input.sharpElem,
    hzvRaw: input.hzvRaw,
    hzvElem: input.hzvElem,
    critRate: critFinal0,
    critMult: ctx.critMult,
    elemBonus: 1.0,
    critAttackElemLv: input.critAttackElemLv,
    roundMode: input.roundMode,
  });

  const single = {
    rank: 1,
    dmg: dmg0,
    type: "なし",      // GASはこの分岐で激化タイプを持たないので「なし」相当
    combo: "—",
    critFinal: critFinal0,
    elemUncapped: elemUncapped0,
    elemCapped: E_final0,
    elemCap: elemCap0,
    isElemCapped: elemUncapped0 > elemCap0,

    atkAdd: 0, elemAdd: 0, affAdd: 0,
    exAtk: 0, exElm: 0, exAff: 0, exTotal: 0,
  };

  return [single];
}


  const results = [];
  const picked = [];
  const exCount = { atk: 0, elm: 0, aff: 0 };
  let atkAdd = 0, elemAdd = 0, affAdd = 0;

  function dfs(depth, startIndex){
    if (depth === n) {
      const combo = picked.map(p => p.id).join(" / ");

      // 末端評価：まずは “復元ボーナスが入った” 単純計算（激化は後で）
      const row = calcSingleWithGekikaBest_(ctx, { atkAdd, elemAdd, affAdd, combo });


      // EX数を載せる（Outputsに合わせる用）
      row.exAtk = exCount.atk;
      row.exElm = exCount.elm;
      row.exAff = exCount.aff;
      row.exTotal = row.exAtk + row.exElm + row.exAff;

      results.push(row);
      return;
    }

    for (let i = startIndex; i < BONUS_OPTIONS.length; i++){
      const opt = BONUS_OPTIONS[i];

      if (opt.isEX) {
        if (exCount[opt.cat] >= 2) continue;
        exCount[opt.cat]++;
      }

      picked.push(opt);
      atkAdd += opt.atk;
      elemAdd += opt.elem;
      affAdd += opt.aff;

      dfs(depth + 1, i); // GASと同じ（同一indexを許容＝重複選択OK）

      affAdd -= opt.aff;
      elemAdd -= opt.elem;
      atkAdd -= opt.atk;
      picked.pop();

      if (opt.isEX) exCount[opt.cat]--;
    }
  }

  dfs(0, 0);

  // dmg降順 → topN
  results.sort((a,b)=> b.dmg - a.dmg);
  const top = results.slice(0, topN).map((r, idx)=> ({...r, rank: idx+1}));

  return top;
}

function buildFixedCtx_(input){
  const critMult = CRIT_MULT_BY_SUPERCRIT[input.superCritLv] ?? 1.25;

  const hzvRaw = Number(input.hzvRaw);
  const shinganActive = Number.isFinite(hzvRaw) && hzvRaw < 0.45;
  const shinganAtkMult = shinganActive ? getShinganAtkMult_(input.shinganLv) : 1.0;

  const A_semeNoShuseiBonus = getSemeNoShuseiBonus(input.semeNoShuseiLv);
  const A_nushiNoTamashiiBonus = input.nushiNoTamashiiOn ? 1.05 : 1.0;

  const atkSkillMult = getAttackSkillMult(input.attackSkillLv);
  const atkSkillAdd  = getAttackSkillAdd(input.attackSkillLv);

  const A_kougekiBonus = getKougekiBonus(input.kougekiLv);
  const A_fullChargeBonus = getFullChargeBonus(input.fullChargeLv);
  const A_gyakushuBonus = getGyakushuBonus(input.gyakushuLv);

  const challenger = getChallengerBonus_(input.challengerLv);
  const rengeki = getRengekiBonus_(input.rengekiLv);
  const rengekiBoostAtkAdd = (input.rengekiLv >= 1) ? getRengekiBoostAtkAdd_(input.rengekiBoostLv) : 0;

  const A_kokushokuIttaiAdd = input.kokushokuIttaiOn ? 15 : 0;

  const atkMultTotal =
    A_semeNoShuseiBonus *
    A_nushiNoTamashiiBonus *
    atkSkillMult *
    shinganAtkMult;

  const atkFlatAfterMultTotal =
    atkSkillAdd +
    A_kougekiBonus +
    A_fullChargeBonus +
    A_gyakushuBonus +
    challenger.atkAdd +
    rengeki.atkAdd +
    rengekiBoostAtkAdd +
    A_kokushokuIttaiAdd;

  const saikaElemMult = getSaikaElemMult_(input.saikaLv);
  const senseiKouou = getSenseiKououBonus_(input.senseiKououLv);
  const elemAtkUpMult = getElemAtkUpMult_(input.elemAtkUpLv);
  const elemAtkUpAdd  = getElemAtkUpAdd_(input.elemAtkUpLv);

  let elemMulted = senseiKouou.elemMult;
  elemMulted *= saikaElemMult;
  elemMulted *= elemAtkUpMult;

  let elemAdded = senseiKouou.elemAdd;
  elemAdded += rengeki.elemAdd;
  elemAdded += elemAtkUpAdd;

  const wexAffAdd = getWeaknessExploitAffAdd_(input.wexLv, hzvRaw);
  const konshinAffAdd = getKonshinAffAdd_(input.konshinLv);
  const chikaraNoKaihouAffAdd = getChikaraNoKaihouAffAdd_(input.chikaraNoKaihouLv);

  const kyouryuuKokufukuAffAdd = input.kyouryuuKokufukuOn ? 0.15 : 0.0;
  const mugaAffAdd = input.kyouryuuKokufukuOn ? getMugaNoKyouchiAffAdd_(input.mugaLv) : 0.0;

  const critExtra =
    wexAffAdd +
    konshinAffAdd +
    chikaraNoKaihouAffAdd +
    challenger.affAdd +
    kyouryuuKokufukuAffAdd +
    mugaAffAdd;

  return {
    input,
    critMult,
    atkMultTotal,
    atkFlatAfterMultTotal,
    elemMulted,
    elemAdded,
    critExtra,
  };
}


function calcSingleWithGekikaBest_(ctx, { atkAdd, elemAdd, affAdd, combo }) {
  const input = ctx.input;

  // --- 復元ボーナス反映後(激化前)の土台（ここだけがDFSで変わる） ---
  const A_restored = input.A_base + atkAdd;
  const elemBase_restored = input.E_base + elemAdd;
  const crit_restored = clamp(input.critBase + affAdd + ctx.critExtra, 0, 1);


  // --- 激化best（固定係数はctxから） ---
  const best = evalBestGekika_({
    A_restored,
    elemBase_restored,
    crit_restored,

    input,
    atkMultTotal: ctx.atkMultTotal,
    atkFlatAfterMultTotal: ctx.atkFlatAfterMultTotal,
    elemMulted: ctx.elemMulted,
    elemAdded: ctx.elemAdded,
    critMult: ctx.critMult,
    critAttackElemLv: input.critAttackElemLv,
  });

  return {
    ...best,
    combo,
    atkAdd,
    elemAdd,
    affAdd,
  };
}





/**
 * これが“外に出す”計算API
 * GASの optimizeRestorationBonuses_Rambu の入口に相当
 */
function calc(input){
  return calcOptimizedTopN(input);
}


function evalBestGekika_({
  // “復元ボーナス反映後(激化前)”の土台
  A_restored,            // A_base + atkAdd
  elemBase_restored,     // E_base + elemAdd
  crit_restored,         // critBase + affAdd + ...（激化前の最終会心率）

  // 入力と、スキル側で固定の係数
  input,
  atkMultTotal,              // 例：攻撃*心眼*ヌシ魂*守勢…など“乗算まとめ”
  atkFlatAfterMultTotal,     // 例：巧撃/フルチャ/逆襲/挑戦者/連撃…など“加算まとめ”
  elemMulted,                // 例：災禍*宣戦*属性強化…など“属性乗算まとめ”
  elemAdded,                 // 例：宣戦加算+連撃加算+属性強化加算…など“属性加算まとめ”
  critMult,                  // ★追加
  critAttackElemLv
}) {
  //const trials = [
  //  { type: "攻撃激化", A_add: +10, crit_add: -0.15, elem_add:  0 },
  //  { type: "会心激化", A_add: -10, crit_add: +0.10, elem_add: -20 },
  //  { type: "属性激化", A_add:   0, crit_add: -0.05, elem_add: +30 },
  //];

  let best = null;

  for (const t of GEKIKA_TRIALS) {
  // --- 激化で変わる“基礎” ---
  const A_mod_base = A_restored + t.A_add;
  const crit_mod   = clamp(crit_restored + t.crit_add, 0, 1);
  const elemBase_mod = Math.max(elemBase_restored + t.elem_add, 0);

  // --- 最終攻撃力（乗算→加算）---
  const A_final = (A_mod_base * atkMultTotal) + atkFlatAfterMultTotal;

  // --- 最終属性（乗算→加算、上限は elemBase_mod 基準）---
  const elemUncapped = (elemBase_mod * elemMulted) + elemAdded;
  const elemCap      = elementCapFromBase(elemBase_mod);
  const E_final      = Math.min(elemUncapped, elemCap);

  const dmg = calcRambuExpectedDamage({
    A: A_final,
    E: E_final,
    sharpRaw: input.sharpRaw,
    sharpElem: input.sharpElem,
    hzvRaw: input.hzvRaw,
    hzvElem: input.hzvElem,
    critRate: crit_mod,
    critMult,
    elemBonus: 1.0,
    critAttackElemLv,
    roundMode: input.roundMode,
  });

  const cur = {
    type: t.type,
    dmg,
    critFinal: crit_mod,
    elemUncapped,
    elemCapped: E_final,
    elemCap,
    isElemCapped: elemUncapped > elemCap,
  };

  if (!best || cur.dmg > best.dmg) best = cur;
}

  return best;
}



/** =========================
 *  ここから「UI」ゾーン
 *  ========================= */



function toRate01(v){
  const x = Number(v);
  if(!Number.isFinite(x)) return NaN;
  if(x > 1) return x / 100;  // 45 -> 0.45
  return x;                  // 0.45 -> 0.45
}

function getInput(){
  return {
    A_base: Number(document.getElementById("A_base").value),
    E_base: Number(document.getElementById("E_base").value),
    sharpRaw: Number(document.getElementById("sharpRaw").value),
    sharpElem: Number(document.getElementById("sharpElem").value),

    hzvRaw: toRate01(document.getElementById("hzvRaw").value),
    hzvElem: toRate01(document.getElementById("hzvElem").value),
    critBase: toRate01(document.getElementById("critBase").value),

    superCritLv: Number(document.getElementById("superCritLv").value),
    attackSkillLv: Number(document.getElementById("attackSkillLv").value),
    elemAtkUpLv: Number(document.getElementById("elemAtkUpLv").value),
    senseiKououLv: Number(document.getElementById("senseiKououLv").value),
    shinganLv: Number(document.getElementById("shinganLv").value),

    // ON/OFF は select の値で拾う（checkboxよりシートに近い）
    kokushokuIttaiOn: document.getElementById("kokushokuIttaiOn").value === "ON",

    // まだ calc() が使ってなくてもOK（後で移植の時に使う）
    totalSlots: Number(document.getElementById("totalSlots").value),
    sharpCnt: Number(document.getElementById("sharpCnt").value),
    topN: Number(document.getElementById("topN").value),
    roundMode: Number(document.getElementById("roundMode").value),

    kougekiLv: Number(document.getElementById("kougekiLv").value),
    fullChargeLv: Number(document.getElementById("fullChargeLv").value),
    semeNoShuseiLv: Number(document.getElementById("semeNoShuseiLv").value),
    gyakushuLv: Number(document.getElementById("gyakushuLv").value),
    nushiNoTamashiiOn: document.getElementById("nushiNoTamashiiOn").value === "ON",

    saikaLv: Number(document.getElementById("saikaLv").value),
    critAttackElemLv: Number(document.getElementById("critAttackElemLv").value),

    wexLv: Number(document.getElementById("wexLv").value),
    konshinLv: Number(document.getElementById("konshinLv").value),
    chikaraNoKaihouLv: Number(document.getElementById("chikaraNoKaihouLv").value),
    kyouryuuKokufukuOn: document.getElementById("kyouryuuKokufukuOn").value === "ON",
    mugaLv: Number(document.getElementById("mugaLv").value),

    challengerLv: Number(document.getElementById("challengerLv").value),
    rengekiLv: Number(document.getElementById("rengekiLv").value),
    rengekiBoostLv: Number(document.getElementById("rengekiBoostLv").value),
  };
}


function render(rows){
  const tbody = document.getElementById("tbody");
  tbody.innerHTML = "";
  for(const r of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.rank}</td>
      <td>${Number(r.dmg).toFixed(3)}</td>
      <td>${r.type ?? ""}</td>
      <td class="mono">${r.combo ?? ""}</td>
      <td>${Number(r.critFinal).toFixed(3)}</td>
      <td>${Number(r.elemUncapped).toFixed(2)}</td>
      <td>${Number(r.elemCapped).toFixed(2)}</td>
      <td>${Number(r.elemCap).toFixed(2)}</td>
      <td class="${r.isElemCapped?'ok':'muted'}">${r.isElemCapped?'YES':'NO'}</td>
    `;
    tbody.appendChild(tr);
  }
}

function setStatus(msg){ document.getElementById("status").textContent = msg; }

document.getElementById("btnCalc").addEventListener("click", () => {
  try{
    const input = getInput();
    const rows = calc(input);
    render(rows);

    document.getElementById("summary").textContent =
      `A=${input.A_base}, E=${input.E_base}, hzvRaw=${input.hzvRaw}, hzvElem=${input.hzvElem} / 結果=${rows.length}件`;

    setStatus("OK");
  }catch(e){
    console.error(e);
    setStatus("エラー: " + (e?.message ?? String(e)));
  }
});

document.getElementById("btnReset").addEventListener("click", () => {
  location.reload();
});




// 公開時のみ広告枠を有効化（今は false）
if (IS_PUBLIC) {
  document.getElementById("ads-bottom").style.display = "block";
}
</script>
</body>
</html>
